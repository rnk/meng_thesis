\chapter{Background}

% Background on design of DynamoRIO, all relevant considerations.

In order to understand the design considerations of the tool optimizations
presented in this thesis, it is important to first understand the design of
DynamoRIO and binary instrumentation frameworks in general.  Pin, DynamoRIO,
and VMWare all use variations on the same underlying technique: binary
translation.

\section{Execution Model}

DynamoRIO does not execute the original application instructions.  Instead, it
interprets the application basic block by basic block.  When DynamoRIO takes
control, it decodes from the first instruction until the next control transfer.
If DynamoRIO has loaded a program analysis tool, it will present the
instructions in the basic block to the tool for instrumentation.  After
instrumentation, DynamoRIO performs further modifications to the instruction
stream in order to maintain control after the basic block finishes executing.
The instructions are encoded into a ``fragment'' in the ``code cache,'' which
is the memory space allocated by DynamoRIO for translated application code.
This process is known as ``translation.''  Finally, DynamoRIO switches back to
the application stack and starts executing the new fragment.

When the basic block finishes execution, instead of executing the original
application control transfer instruction, it will execute a modified jump which
will re-enter the DynamoRIO VM with information about the original target
application program counter.  If the target application PC is not in the code
cache yet, DynamoRIO will then repeat the process of translation for the next
basic block.  After translation, it will return to the application context and
re-start execution from the freshly translated fragment.

Additionally, as perhaps the most important optimization in DynamoRIO, the two
basic blocks will be ``linked'' together.  This involves modifying the
terminating control transfer instruction from the previous fragment to directly
jump to the beginning of the new fragment.  Other bookkeeping structures are
also updated to support unlinking of fragments, which is important for
supporting self-modifying code.

TODO: Perhaps some figures?

\section{Transparency}

One of the primary requirements of systems like DynamoRIO is that the
application should run as if it were running on the native OS and hardware.
This means that DynamoRIO should be able to run self-modifying code and handle
stack crawlers as if they were running natively.  DynamoRIO observes two
guidelines to make this possible.

First, leave anything about the application unchanged if possible.  For
example, DynamoRIO never touches the application stack or even assumes that it
is valid.  This complicates context switching out of the application and back
to DynamoRIO, which is described in the next section.
% TODO: ref?

Second, if it is not possible to leave the application unchanged, pretend that
it still is.  An example of this is that DynamoRIO needs to protect application
code from modification in order to maintain code cache consistency.  However,
the application must not know about this write protection, or it may change
behavior.  Therefore, DynamoRIO must intercept system calls that query this
state and emulate them as if the application were undisturbed.

There are many other transparency concerns that DynamoRIO abstracts away from
program analysis tool authors which are described at length in the previous
work.  Our main concern with transparency is the way that it constrains the
design of context switching, which is important for tool performance.

\section{Context Switching}

%
% Separate stack for DR execution.

% TODO: Is this a useful section?

In order to maintain transparency, DynamoRIO must switch to a clean stack
before executing any significant amount of non-application code.  In order to
do this, DynamoRIO must be able to spill some of the general purpose registers
quickly without using or pre-reserving an additional register, as is done in
some systems.\cite{TODO}  DynamoRIO's context switching works roughly as
follows:

\begin{enumerate}
\item Spill one register to a thread local scratch space, discussed later.
\item Load the address of a thread local structure describing DynamoRIO's
context into the register.
\item Spill the application stack pointer to the DynamoRIO context through the
register.
\item Load DyanamRIO's stack pointer into the stack pointer register.
\item Push all application registers to the DynamoRIO stack in a pre-defined
format.
\end{enumerate}

When switching back to the application context, the sequence is roughly
reversed.

\section{Scratch Space}

% Thread local storage concerns, especially design for Windows.

Code injected by DynamoRIO or analysis tools will generally need registers for
computation.  Before they can be used, they must be spilled to a reserved
memory area from which they can be reloaded after the injected code is
finished.

If the application is single-threaded, the simple solution is to encode an
absolute address into the code cache for use as scratch space.  However,
multiple threads cannot share the same scratch space, and DynamoRIO wishes to
share the code cache between threads.  While this works for single-threaded
applications or if DynamoRIO is configured to use thread-private code caches,
it is not a good solution.

Another solution is to attempt to use the application stack.  However, this
violates transparency, as it can fail if the stack is about to overflow or in
other corner cases.

DynamoRIO's default solution is to use the x86 {\tt FS} and {\tt GS} segment
registers, which are normally used by the operating system to support thread
local storage.  On both Windows and Linux, DynamoRIO steals from this
thread-local storage area for its own scratch space.

\subsection{Linux TLS}

On Linux, the solution is simple.  For x86\_32, the pthreads implementation
uses the {\tt GS} segment to support thread local storage.  For x86\_64, {\tt
FS} was chosen for the same purpose.  In either case, one segment is unused by
pthreads, so DynamoRIO steals it and sets its base to its own thread local
scratch area.  This makes TLS space a very cheap resource on Linux, since
DynamoRIO can allocate and address as much memory as it likes from its private
segment base, which is very useful.

Currently, stealing a segment register is a violation of transparency, as it is
possible for the application to request the same resource, and DynamoRIO has no
mechanism for emulating this.  There has been recent work to mangle application
accesses to DynamoRIO's thread local storage, but it has not yet been released.

\subsection{Windows TLS}

On Windows, the situation is much more complex.  The {\tt FS} segment base is
used for the Thread Execution Block (TEB)\cite{TODO}, and {\tt GS} is unused.
However, while the application may set the segment base for the {\tt GS}
segment register, Windows will reset it to zero on every context switch back
into the kernel.  Since this can happen at any arbitrary instruction, it is not
feasible to use the {\tt GS} segment for any purpose.

Instead, DynamoRIO piggybacks on the native TLS implementation on Windows.
Within the TEB, Windows has an array of 64 pointers for dynamic TLS storage, as
well as a pointer to a larger, 1024 element array for further storage.  The
dynamic array is the only area suitable for use as scratch space by DynamoRIO,
because it is addressable with a single x86 memory operand.  When DynamoRIO
takes control, it examines the TEB and looks for free, contiguous TLS slots at
the end of dynamic TLS array in the TEB.  It marks them as allocated to prevent
the application from using them, and records the offset from the segment base
for future use.

As in Linux, this solution is also a minor transparency violation.  The slots
are stolen from the end of the TEB TLS array to avoid disturbing application
allocations, but if the application runs out of dynamic TLS slots, there may be
issues.  This might occur, for example, if there are more than 64 DLLs that use
TLS.  Based on industrial experience running large Windows applications such as
Microsoft Exchange, DynamoRIO limits itself to stealing 5 slots on Windows.

\subsection{Consequences}

The upshot of DynamoRIO's scratch space usage is that depending on the
operating or application run under DynamoRIO, scratch space may either be
plentiful or scarce.  This has ramifications when attempting to automatically
inline tool code, and especially for whether or not we can avoid switching
stacks.
