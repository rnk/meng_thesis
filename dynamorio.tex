\chapter{Background}

% Background on design of DynamoRIO, all relevant considerations.

In order to understand the design considerations of the tool optimizations
presented in this thesis, it is important to first understand the execution
model of DynamoRIO and binary instrumentation frameworks in general.
Pin\cite{pin}, DynamoRIO, and Valgrind\cite{valgrind} all use variations on the
same underlying code cache techniques.  Even VMWare, before the introduction of
hardware support for virtualization in the CPU, used the same techniques in
binary translation.\cite{vmware_comparison}

\section{Execution Model}

DynamoRIO does not execute the original application instructions.  Instead, it
interprets the application code one basic block at a time.  When DynamoRIO takes
control, it decodes instructions from the first instruction until the next
control transfer.  If DynamoRIO has loaded a program analysis tool, it will
present the instructions in the basic block to the tool for instrumentation.
After instrumentation, DynamoRIO performs further modifications to the
instruction stream in order to maintain control after the basic block finishes
executing.  The instructions are encoded into a ``fragment'' in the ``code
cache,'' which is the memory space allocated by DynamoRIO for translated
application code.  This process is known as ``translation.''  Finally, DynamoRIO
switches back to the application stack and starts executing the new fragment.

When the basic block finishes execution, instead of executing the original
application control transfer instruction, it will execute a modified jump which
will re-enter the DynamoRIO VM with information about the original target
application program counter.  If the target application PC is not in the code
cache yet, DynamoRIO will then repeat the process of translation for the next
basic block.  After translation, it will return to the application context and
re-start execution from the freshly translated fragment.

Additionally, as perhaps the most important optimization in DynamoRIO, if the
control transfer target is direct, the two basic blocks will be ``linked''
together.  This is accomplished by modifying the terminating control transfer
instruction from the previous fragment to directly target to the beginning of
the new fragment.  Other bookkeeping structures are also updated to support
unlinking of fragments, which is important for supporting self-modifying code.
As a result, when a code path executes more than once, it will not have to leave
the application context to look up the fragment for the target PC in the
DynamoRIO VM.

% TODO: Perhaps some figures?

\section{Transparency}
\label{sec:transparency}

One of the primary requirements for DynamoRIO and systems like it is that the
application should run as if it were running on the native OS and hardware.  For
example, all control flow decisions made by the native application with the same
inputs should be exactly the same in the emulated execution.  Even a best effort
should be made to leave the memory layout completely undisturbed, or the native
execution will be different.  This means that DynamoRIO must also handle corner
cases like self-modifying code and stack crawlers as if they were running
natively.  DynamoRIO observes two guidelines to make this possible.

First, leave anything about the application unchanged if possible.  For example,
DynamoRIO never touches the application stack or even assumes that it is valid.
This complicates context switching out of the application and back to DynamoRIO,
which is described in Section \ref{sec:context_switching}.

Second, if it is not possible to leave the application unchanged, pretend that
it still is.  An example of this is that DynamoRIO needs to protect application
code from modification in order to maintain code cache consistency.  However,
the application must not know about these page protections, or it may change
behavior.  Therefore, DynamoRIO must intercept system calls that query this
state and emulate them as if the application were running natively.

There are many other transparency concerns that DynamoRIO abstracts away from
program analysis tool authors which are described at length in the previous
work.  Our main concern with transparency is the way that it constrains the
design of context switching, which is important for tool performance.

\section{Context Switching}
\label{sec:context_switching}

In order to execute any non-trivial amount of code outside the application,
DynamoRIO must perform a ``context switch.''  In order to maintain transparency,
all application registers must be spilled to a safe location and a clean stack
must be used.  DynamoRIO's context switching works roughly as follows:

\begin{enumerate}
\item Spill one register to the reserved scratch space, discussed later.  % ref
\item Load the address of a thread local {\tt drcontext} structure, which
describes the execution context of the current thread.
\item Spill the application stack pointer to the {\tt drcontext} through the
register.
\item Load DyanamRIO's stack pointer into the stack pointer register.
\item Push all application registers to the DynamoRIO stack.
\end{enumerate}

If the context switch code was caused by a clean call, then the callee routine
will be called immediately.  If the context switch is caused by any other
reason, DynamoRIO enters the main dispatch routine to decide how to re-start
execution next.  Clean calls are the main focus of this thesis.

When switching back to the application context, the sequence is roughly
reversed.

\section{Scratch Space}

% Thread local storage concerns, especially design for Windows.

Code injected by DynamoRIO or analysis tools will generally need registers for
computation.  Before they can be used, they must be spilled to a reserved memory
area from which they can be reloaded after the injected code is finished.

If the application is single-threaded, the simple solution is to encode an
absolute address into the code cache for use as scratch space.  However,
multiple threads cannot share the same scratch space, and DynamoRIO wishes to
share the code cache between threads.  While this works for single-threaded
applications or if DynamoRIO is configured to use thread-private code caches, it
is not a good solution.

Another solution is to attempt to use the application stack.  However, this
violates transparency, as it can fail if the stack is about to overflow or in
other corner cases.

A third solution used by some instrumentation frameworks is to reserve a general
purpose register to address the scratch space.  This approach was first used in
Dynamo on the register-rich Alpha architecture.\cite{dynamo}  However, on a
register-poor architecture like x86\_32, stealing a register has a much higher
penalty.  During the design of DynamoRIO this approach was implemented for
comparison and it resulted in slowdowns on some benchmarks of up to 20\%.

DynamoRIO's preferred solution is to use the x86 {\tt FS} and {\tt GS} segment
registers, which are normally used by the operating system to support thread
local storage.  On both Windows and Linux, DynamoRIO steals from this
thread-local storage area for its own scratch space.

\subsection{Linux TLS}

On Linux, the solution is simple.  For x86\_32, the pthreads implementation uses
the {\tt GS} segment to support thread local storage.  For x86\_64, {\tt FS} was
chosen for the same purpose.  In either case, one segment is unused by pthreads,
so DynamoRIO steals it and sets the segment base base to its own thread local
scratch area.  This means the TLS scratch space can be very large on Linux,
since DynamoRIO can allocate and address as much memory as it likes from its
private segment base, which is very useful.

Currently, stealing a segment register is a violation of transparency, as it is
possible for the application to request the same resource, and DynamoRIO has no
mechanism for emulating this.  There has been recent work to mangle application
accesses to the conflicting segment register, but it has not yet been released.

\subsection{Windows TLS}
\label{sec:windows_tls}

On Windows, the situation is much more complex.  The {\tt FS} segment base is
used for the Thread Execution Block (TEB)\cite{inside_win2k}, and {\tt GS} is
unused.  However, while the application may set the segment base for the {\tt
GS} segment register, Windows will reset it to zero on every context switch back
into the kernel.  Since this can happen at any arbitrary instruction, it is not
feasible to use the {\tt GS} segment for any purpose.

Instead, DynamoRIO piggybacks on the native TLS implementation on Windows.
Within the TEB, Windows has an array of 64 pointers for dynamic TLS storage, as
well as a pointer to a larger, 1024 element array for further storage.  The
dynamic array is the only area suitable for use as scratch space by DynamoRIO,
because it is addressable with a single x86 memory operand.  When DynamoRIO
takes control, it examines the TEB and looks for free, contiguous TLS slots in
the dynamic TLS array in the TEB.  It marks them as allocated to prevent the
application from using them, and records the offset from the segment base for
future use.

As in Linux, this solution is also a minor transparency violation.  The slots
are stolen from the end of the TEB TLS array to avoid disturbing application
allocations, but if the application runs out of dynamic TLS slots, there may be
issues.  Based on industrial experience running large Windows applications such
as Microsoft Exchange, DynamoRIO limits itself to stealing 5 slots on Windows.

\subsection{Consequences}

The upshot of DynamoRIO's scratch space usage is that depending on the operating
system or application run under DynamoRIO, scratch space may be either a
plentiful or scarce resource.  This has ramifications when attempting to
automatically inline tool code, and especially for whether or not we can avoid
switching stacks by using extra scratch space.

\section{Tool Interface}

Although DynamoRIO was originally built as an optimization platform and
commercialized as a security product, it is mainly used today as a framework for
building instrumentation tools.  This section covers the interface that
DynamoRIO presents today.

% Perhaps full naive inscount client source?  Maybe reference appendix?  Yes.
% dr_register_bb_event
% dr_insert_clean_call
% performance and code bloat impact of clean call
